/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* 'frameworks/native/services/inputflinger/tests/TestInputListener.cpp'
 *  is used as reference to come up with file
 *  Only code pertaining to gtest 'Process_DeactivateViewport_AbortTouches' is
 *  retained
 */

#include "TestInputListener.h"

namespace android {

// --- TestInputListener ---

TestInputListener::TestInputListener(std::chrono::milliseconds eventHappenedTimeout,
                                     std::chrono::milliseconds eventDidNotHappenTimeout)
      : mEventHappenedTimeout(eventHappenedTimeout),
        mEventDidNotHappenTimeout(eventDidNotHappenTimeout) {}

TestInputListener::~TestInputListener() {}

template <class NotifyArgsType>
void TestInputListener::assertCalled(NotifyArgsType* outEventArgs, std::string message) {
    std::unique_lock<std::mutex> lock(mLock);
    base::ScopedLockAssertion assumeLocked(mLock);

    std::vector<NotifyArgsType>& queue = std::get<std::vector<NotifyArgsType>>(mQueues);
    if (queue.empty()) {
        const bool eventReceived =
                mCondition.wait_for(lock, mEventHappenedTimeout,
                                    [&queue]() REQUIRES(mLock) { return !queue.empty(); });
        if (!eventReceived) {
            return;
        }
    }
    if (outEventArgs) {
        *outEventArgs = *queue.begin();
    }
    queue.erase(queue.begin());
}

template <class NotifyArgsType>
void TestInputListener::assertNotCalled(std::string message) {
    std::unique_lock<std::mutex> lock(mLock);
    base::ScopedLockAssertion assumeLocked(mLock);

    std::vector<NotifyArgsType>& queue = std::get<std::vector<NotifyArgsType>>(mQueues);
    const bool eventReceived =
            mCondition.wait_for(lock, mEventDidNotHappenTimeout,
                                [&queue]() REQUIRES(mLock) { return !queue.empty(); });
    if (eventReceived) {
        return;
    }
}

template <class NotifyArgsType>
void TestInputListener::notify(const NotifyArgsType* args) {
    std::scoped_lock<std::mutex> lock(mLock);

    std::vector<NotifyArgsType>& queue = std::get<std::vector<NotifyArgsType>>(mQueues);
    queue.push_back(*args);
    mCondition.notify_all();
}

void TestInputListener::notifyConfigurationChanged(const NotifyConfigurationChangedArgs* args) {
    notify<NotifyConfigurationChangedArgs>(args);
}

void TestInputListener::notifyDeviceReset(const NotifyDeviceResetArgs* args) {
    notify<NotifyDeviceResetArgs>(args);
}

void TestInputListener::notifyKey(const NotifyKeyArgs* args) {
    notify<NotifyKeyArgs>(args);
}

void TestInputListener::notifyMotion(const NotifyMotionArgs* args) {
    notify<NotifyMotionArgs>(args);
}

void TestInputListener::notifySwitch(const NotifySwitchArgs* args) {
    notify<NotifySwitchArgs>(args);
}

void TestInputListener::notifyPointerCaptureChanged(const NotifyPointerCaptureChangedArgs* args) {
    notify<NotifyPointerCaptureChangedArgs>(args);
}

void TestInputListener::notifySensor(const NotifySensorArgs* args) {
    notify<NotifySensorArgs>(args);
}

void TestInputListener::notifyVibratorState(const NotifyVibratorStateArgs* args) {
    notify<NotifyVibratorStateArgs>(args);
}

} // namespace android
