// Copyright 2020 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
/*
 * generated from files in sound-open-firmware-private/src/include:
 * kernel/header.h
 * ipc/control.h
 */

/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}
pub type __uint32_t = ::std::os::raw::c_uint;
/// \brief Header for all non IPC ABI data.
///
/// Identifies data type, size and ABI.
/// Data header used for all component data structures and binary blobs sent to
/// firmware as runtime data. This data is typically sent by userspace
/// applications and tunnelled through any OS kernel (via binary kcontrol on
/// Linux) to the firmware.
#[repr(C, packed)]
pub struct sof_abi_hdr {
    ///< 'S', 'O', 'F', '\0'
    pub magic: u32,
    ///< component specific type
    pub type_: u32,
    ///< size in bytes of data excl. this struct
    pub size: u32,
    ///< SOF ABI version
    pub abi: u32,
    ///< reserved for future use
    pub reserved: [u32; 4usize],
    ///< Component data - opaque to core
    pub data: __IncompleteArrayField<u32>,
}
#[test]
fn bindgen_test_layout_sof_abi_hdr() {
    assert_eq!(
        ::std::mem::size_of::<sof_abi_hdr>(),
        32usize,
        concat!("Size of: ", stringify!(sof_abi_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<sof_abi_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(sof_abi_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sof_abi_hdr>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sof_abi_hdr>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sof_abi_hdr>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sof_abi_hdr>())).abi as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(abi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sof_abi_hdr>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sof_abi_hdr>())).data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sof_abi_hdr),
            "::",
            stringify!(data)
        )
    );
}
///< maps to ALSA volume style controls
pub const sof_ipc_ctrl_cmd_SOF_CTRL_CMD_VOLUME: sof_ipc_ctrl_cmd = 0;
///< maps to ALSA enum style controls
pub const sof_ipc_ctrl_cmd_SOF_CTRL_CMD_ENUM: sof_ipc_ctrl_cmd = 1;
///< maps to ALSA switch style controls
pub const sof_ipc_ctrl_cmd_SOF_CTRL_CMD_SWITCH: sof_ipc_ctrl_cmd = 2;
///< maps to ALSA binary style controls
pub const sof_ipc_ctrl_cmd_SOF_CTRL_CMD_BINARY: sof_ipc_ctrl_cmd = 3;
/// Control command type.
pub type sof_ipc_ctrl_cmd = u32;
